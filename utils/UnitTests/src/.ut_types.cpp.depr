# include <iomanip>
# include "utest.hpp"
# include "hph_exception.hpp"
# include "hph_buffer.hpp"

char binbf[9];
char binbf2[9];

// #define VRB
void test_reflexive_id( const ULong dLen, std::ostream & _ss ) {
    UByte nBytes = refl_descriptive_size_len( dLen );
    # ifdef VRB
    _ss << "Offered " << (int) nBytes << " bytes for intr. block encoding." << std::endl;
    # endif

    # ifdef VRB
    _ss << "Original " << dLen << " number in binary:" << std::endl << "  ";
    for( UByte i = 0; i < sizeof(dLen); ++i ) {
        _ss << binary_to_string( *( ((UByte*) &dLen) + (sizeof(dLen)-i-1)), binbf ) << "  ";
    } _ss << std::endl;
    _ss << "  12345678  abcdefgh  12345678  abcdefgh  12345678  abcdefgh  12345678  abcdefgh" << std::endl;
    # endif
    Refl R[8]; memset( R, 0, sizeof(R) );
    refl_encode_descriptive_len( dLen, R, nBytes );
    # ifdef VRB
    _ss << "Encoded number in binary:" << std::endl << "  ";
    for( UByte i = 0; i < sizeof(dLen); ++i ) {
        _ss << binary_to_string( R[i], binbf ) << "  ";
    } _ss << std::endl;
    _ss << "  ---cdefg  -45678ab  -efgh123  ????????  ????????  ????????  ????????  ????????" << std::endl;
    # endif

    ULong dLenDecoded = refl_parse_descriptive_len(R);
    # ifdef VRB
    _ss << "Decoded " << dLenDecoded << " number in binary:" << std::endl << "  ";
    for( UByte i = 1; i < sizeof( dLenDecoded ); ++i ) {
        _ss << binary_to_string( *( ((UByte*) & dLenDecoded) + (sizeof(dLenDecoded)-i-1)), binbf ) << "  ";
    } _ss << std::endl;
    _ss << "  12345678  abcdefgh  12345678  abcdefgh  12345678  abcdefgh  12345678  abcdefgh" << std::endl;
    # endif
    _ASSERT( dLen == dLenDecoded, "Composite reflexive code erroneouse \
(de)coding for number %lu (decoded as %lu)", dLen, dLenDecoded );
}

HPH_UT_BGN( Type_introspection_conversions )

_ss << "== Atomic" << std::endl;
{   // check atomic type ID correctness
    Refl R;

    # define check_atomic(num, cType, name, min, max) { \
        R = num; \
        _ss << std::setw(10) \
            << #name << ": " << std::setw(20) \
            << #cType << ", code: " << std::setw(3) \
            << (int) num << " : " << std::setw(9) \
            << binary_to_string(num, binbf) << std::endl; \
        _ASSERT( refl_is_atomic(&R), "Type" #name "has invalid repr: %s", binary_to_string(num, binbf) ) \
        _ASSERT( num == refl_atomic_type_code(&R), "Conversion routine failed for %d type!", (int) num ) }
    for_all_atomic_datatypes(check_atomic)
    # undef check_atomic
}
_ss << "== Composite" << std::endl;
{   // check registered type conversion correctness
    const UShort toCheck = 11333;
    Refl R[2];

    _ss << "-> Type ID: " << std::setw(10) << toCheck << ", binary: "
       << binary_to_string( *( ((UByte *) &toCheck) + 1), binbf  ) << " "
       << binary_to_string( *( ((UByte *) &toCheck)    ), binbf2 )
       << std::endl;
    *((unsigned short*) R) = refl_cnv_ctype_id( toCheck );
    _ss << "Reflection: " << std::setw(10) << *((unsigned short*) R) << ", binary: "
       << binary_to_string( R[1], binbf  ) << " "
       << binary_to_string( R[0], binbf2 )
       << std::endl;
    const UShort toCheckBack = refl_comp_type_id( R );
    _ss << "<- Type ID: " << std::setw(10) << toCheckBack << ", binary: "
       << binary_to_string( *( ((UByte *) &toCheckBack) + 1), binbf  ) << " "
       << binary_to_string( *( ((UByte *) &toCheckBack)    ), binbf2 )
       << std::endl;
    _ASSERT( toCheckBack == toCheck,
        "invalid conversion from reflection to composite type ID" );
}
_ss << "== Composite Reflexive" << std::endl;
{
# if 1
    for( ULong i = 0; i < descriptiveLenMax; i <<=1, i |= 1 ) {
        test_reflexive_id( i, _ss );
    }
# endif
}
//_ASSERT( false, "gimme a log" );

HPH_UT_END( Type_introspection_conversions )


