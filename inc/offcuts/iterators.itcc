
/**@file iterators.itcc
 * @brief file contains declaration of iterable mixin
 *        implementation nested classes.
 *
 *  One should probably never attend to this file separately
 *  from iterable mixin.
 */

template<typename EndIteratorClassT>
class IteratorBase : public PostfixIncOp<EndIteratorClassT> {
public:
    typedef Self Authority;
    typedef EndIteratorClassT EndIteratorClass;
private:
    Authority * _authorityPtr;  ///< no check for authority for performance.
    IteratorSym _sym;
    void _check_authority_is_set() const { DBG_NULLPTR_CHECK( _authorityPtr, "Empty iterator %p.", this ); }
public:
    // Ctr/dtr
    IteratorBase() : _authorityPtr(nullptr) {}
    IteratorBase( const IteratorSym & d ) : 
            _authorityPtr(nullptr), _sym(d) {}

    // authority acquizition:
    Authority & authority() {
            _check_authority_is_set();
            return *_authorityPtr; }
    const Authority & authority() const {
            _check_authority_is_set();
            return *_authorityPtr; }

    // increment:
    virtual EndIteratorClass & operator++() override {
        _check_authority_is_set();
        _authorityPtr->_V_increase_iterator_sym( _sym );
    }
};

template<typename EndIteratorClassT>
class BidirectIterator : public PrefixIncOp<EndIteratorClassT> {
public:
    // decrement:
    virtual EndIteratorClass & operator--() override {
        _check_authority_is_set();
        _authorityPtr->_V_increase_iterator_sym( _sym );
    }
};

// vi: ft=cpp
