/*
 * Copyright (c) 2016 Renat R. Dusaev <crank@qcrypt.org>
 * Author: Renat R. Dusaev <crank@qcrypt.org>
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

# include <cerrno>
# include <cstring>
# include "goo_utility.h"
# include "goo_app.hpp"

namespace goo {

//
// iApp
//

/**@namespace aux
 *
 * Sys namespace constains Goo auxillary classes. One usually
 * has no need to deal with these objects.
 */ namespace aux {

/**@class iApp
 * One probably should never inherit this class directly.
 *
 * Provides some non-template UNIX-specific system routines
 * like signal handling.
 *
 * One can insert arbitrary number of signal handlers.
 * When signal accepted, handling functions should be
 * invoked in reverse order of addition (the oldest is last).
 *
 * Currently, only following signal can be handled (descriptions taken
 * from http://www.yolinux.com/TUTORIALS/C++Signals.html):
 *  + SIGHUP (1)    -- Hangup (POSIX) Report that user's terminal is
 *                  disconnected. Signal used to report the termination
 *                  of the controlling process.
 *  + SIGINT (2)    -- Interrupt (ANSI) Program interrupt. (ctrl-c).
 *  + SIGFPE (8)    -- Floating-Point arithmetic Exception (ANSI). This
 *                  includes division by zero and overflow. The
 *                  IEEE Standard for Binary Floating-Point Arithmetic
 *                  (ANSI/IEEE Std 754-1985) defines various
 *                  floating-point exceptions.
 *  + SIGUSR1 (10)  -- User-defined signal 1
 *  + SIGUSR2 (12)  -- User-defined signal 2
 *  + SIGPIPE (13)  -- Broken pipe (POSIX) Error condition like trying
 *                  to write to a socket which is not connected.
 *  + SIGALARM (14) -- Alarm clock (POSIX) Indicates expiration of a
 *                  timer. Used by the alarm() function.
 *  + SIGTERM (15)  -- Termination (ANSI) This signal can be blocked,
 *                  handled, and ignored. Generated by "kill" command.
 *  + SIGCHLD (17)  -- Child status has changed (POSIX) Signal sent to
 *                  parent process whenever one of its child processes
 *                  terminates or stops.
 *  + SIGCONT (18)  -- Continue (POSIX) Signal sent to process to make
 *                  it continue.
 *  + SIGSTP (20)   -- Keyboard stop (POSIX) Interactive stop signal.
 *                  This signal can be handled and ignored. (ctrl-z)
 * 
 */

iApp * iApp::_self = nullptr;

/** The suppressDefault parameter has only sense when currently adding
 * handler is first. Whein suppressDefault=true, the default system
 * handler will be ignored.
 * @param code UNIX signal ID.
 * @param f callback instance
 * @param suppressDefault do default handler suppression.
 */ void
iApp::add_handler( SignalCode code,
                   SignalHandler f,
                   const std::string description,
                   bool suppressDefault ) {
    // try to find and append appropriate handlers stack
    auto _it = _handlers.find( code );
    if( _it != _handlers.end() ) {
        _it->second.push_back(
                std::pair<SignalHandler, std::string>(
                        f, description
                    )
            );
        if( suppressDefault ) {
            wprintf( "default system \
handler suppression has no effect when adding \
handler is not first in stack." );
        }
        return;  // appending done, exit
    }

    // signal unbound -- bind own dispatcher to treat the signal
    struct sigaction act;
    struct sigaction oldAct;
    bzero( &act, sizeof(act) );
    bzero( &act, sizeof(oldAct) );
    act.sa_sigaction = &(iApp::_signal_handler_dispatcher);
    act.sa_flags = SA_SIGINFO;
    if( sigaction(SIGINT, &act, &oldAct) < 0 ) {
        emraise(common,"sigaction() error\n" );
    }
    // signal bound to dispatcher, now append the handlers stack
    std::vector< std::pair<SignalHandler, std::string> > vec;
    if( oldAct.sa_handler != SIG_DFL && !suppressDefault ) {
        vec.push_back( std::pair<SignalHandler, std::string>(
                oldAct.sa_sigaction, "default handler") );
    }
    vec.push_back( std::pair<SignalHandler, std::string>(f, description) );
    _handlers[code] = vec;
};

/** Uses STL's stream instance to dump registered handlers
 * line-by-line in format:
 *  Signal: <signal ID>
 *      <callback pointer address> <user's callback description>
 *      ...
 *
 * @param os STL's ostream to print in.
 */ void
iApp::dump_handlers( std::ostream & os ) const {
    for( auto it = _handlers.cbegin(); it != _handlers.cend(); ++it ) {
        os << "Signal: " << it->first << std::endl;
        for(auto iit = it->second.cbegin(); iit != it->second.cend(); ++iit){
            os << "\t" << iit->first << " " << iit->second << std::endl;
        }
    }
}

void
iApp::_signal_handler_dispatcher( int signum,
                                  siginfo_t *info,
                                  void * context ) {
    auto entry = iApp::self()._handlers.find( (SignalCode) signum);
    for( auto it  = entry->second.crbegin();
              it != entry->second.crend(); ++it){
        (it->first)( signum, info, context );
    }
}

/** Raises 'common' exception on failure.
 */ std::string
iApp::hostname() const {
    char bf[128];
    if( -1 == gethostname( bf, 128 ) ) {
        emraise( common, "Failed to get hostname: (%d) %s",
            errno, strerror(errno) );
    }
    return bf;
}

/** Raises noSuchKey on failure.
 *
 * @param nm name of environmental variable (e.g. PATH)
 */ std::string
iApp::envvar( const std::string & nm ) const {
    char * var = getenv(nm.c_str());
    if(!var) {
        emraise(noSuchKey, "No such envvar in current context: %s", nm.c_str());
    }
    return var;
}

}  // namespace goo::aux


//
// App
//

};  // namespace goo

