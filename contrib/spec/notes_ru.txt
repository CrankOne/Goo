Мотивировка
    Часто в прикладных задачах возникает необходимость в физическом
    калькуляторе, который бы имел возможность оперировать не только с числами,
    но и с физическими величинами в смысле числа, имеющего размерность (массы,
    энергии, длины, etc). Подобную задачу можно было бы решить, привлекая
    символьные вычисления, однако использовать большие системы здесь не
    видится разумным в силу сравнительной незначительности проблемы ---
    современные развитые интерпретаторы, поддерживающие символьные вычисления
    представляют собой довольно большие и тяжёлые системы, в то время как
    простейшие операции численных подстановок и последующих арифметических
    преобразований могут быть осуществлены в довольно лаконичной форме.

    GDS представляет собой функциональный интерпретируемый язык с возможностью
    перегружать лексику. Его основное применение состоит в параметризации
    исполняющего кода для прикладных расчётов --- написание файлов
    конфигурации, задание и операции Constructive Solid Geometry (CSG),
    параметризация численных методов, обуславливание задач для них.

    Он представлен описанными в формате YACC/BISON LEX/FLEX лексикой и
    грамматикой и открытым интерфейсом для модуля math-evaluation,
    потенциально позволяющим использовать различные процессоры символьных
    вычислений в качестве модуля (далее --- Evaluator).

    Цикл обработки включает в себя последовательный разбор чисто‐декларативных
    элементов (Scopes), результатом которого является промежуточное
    семантическое представление. На этом этапе возможно привлечение
    Evaluator лениво разрешающего некоторые символы (в зависимости от вида
    применяемого Evaluator). Естественно, более развитые математические
    системы могут поддерживать, например, сравнение символьных выражений, но
    штатный Evaluator не способен, например, сравнить два полинома (однако,
    возможно сравнить результат их вычислений).

    Семантика математических выражений обусловливается в той же грамматике
    GDS, однако только в рамках языкового подмножества.

Термы языка:
    = Instruction
    - последовательность, чей первый символ в строке начинается с
    восклицательного знака. Управляем поведением интерпретатора, не является
    декларацией. В некоторых случаях появление инструкции может приводить к
    непредсказуемым последствиям (например, переключение Evaluator внутри
    Scope, где объявлены и будут использоваться математические выражения,
    преобразованные другим Evaluator), поэтому, при их использовании
    необходимо тщательно принимать во внимание области разрешённого
    использования конкретной инструкции.
    = Declaration
    - объявляет запись. Объявление может быть неименованным, и в таком случае
      является хранится в памяти как корневое выражение до конца текущей
      сессии.
      В общем случае состоит из имени, квалификатора релевантности и тела
      выражения. Например:
        0;
        a = 5;
        b = 1, 2;  # эквивалентно b = [1, 2];
        c = { one = 1; two = 2.; three = "three"; };
        Numeric c = 1.23;
        d <- a;
        e <- d + b;
        x(a) <- 2*a;
        y(a) = x(a);
      Квалификаторы релевантности устанавливают связь между частями декларации:
      `=' равенство. Добавляет символ в текущем Scope, с именем слева, пытаясь
      немедленно сконструировать его из выражения справа.
      `<-' Инъекция. Добавляет символ в текущем Scope, но не конструирует его
      тип, а запоминает промежуточную форму ассоциированную с именем.
      `<=>' Биекция. В зависимости от контекста имеет значения:
        - form of bi-assotiative array
        - form of non-standard indexed enumerated array
        - rewriting rule for math processor
      TODO ...
    = Expression
        Как правило алгебраическое выражение, определяющее TODO ...
    = Scope
    - список выражений. Может существовать в виде списка (List) или
    ассоциативного массива (SymTable). Смешанная форма (как Object в JS)
    не позволяется.
    Список состоит из неименованных идущих подряд выражений:
        { 1, 2, 3 };
    Поддерживается непосредственная индексация через операцию `[]'. Так
    выражение:
        { 1, 2, 3, 4 }[2] == 3
    истинно.
    Ассоциативный массив (SymTable):
        { one = 1, two = 2, `something else' = 3 };
    Имена идентификаторов ассоциативного массива не могут начинаться с цифры,
    но могут содержать пробел (в этом случае идентификатор нужно помещать в
    кавычки).
    


Виды кавычек:
    Все виды кавычек используются для обозначения текстовых терминалов или
    значений типа int8_t.
    Backquote (``) применяется для указания единичного символа (e.g. `1`,
    `2`, `2`, ` `, etc.). Возможно задание символа через число как через
    двойной апостроф в C/C++: `\071`, `\0x1f`, etc. Поведение может быть
    модифицировано добавлением префиксной литеры L.
    Двойные кавычки создают произвольный текстовый литерал. Поведение может
    быть модифицировано добавлением префиксной литеры L.
    Для многострочных текстовых терминалов применяются тройные двойные кавычки
    (как в Python), которые так же могут быть дополнены префиксной литерой L
    для создания расширенного литерала.
    Комбинация backquote (`) в качестве открывающей кавычки и апострофа (')
    соответствует однострочному текстовому литералу, содержащему
    алфавитно‐цифровые символы и пробел — позволяет использовать произвольный текст в
    качестве идентификатора — служит для упрощения лексического анализа.
    Использование одиночного апострофа (') в строке не содержащей незакрытых
    backquote может быть интерпретировано, например, как знак фута (дюйма).



