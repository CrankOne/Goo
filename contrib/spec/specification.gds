#
# Basics
#

a = 1;           # Named numerical constant declaration of Integral class.

Int8 b = 2;      # Named numerical constant declaration of explicitly
                 # specified integral type of 8bit length.

Float8 c = 6/2;  # Arithmetics will be evaluated whenever it is possible.


#
# A bit of functional programming
#

#
# Generators are not a usual variable

ag <- /0..1..50/;
bg <- ag*10;        # b is /0..10..500/
cg <- ag^2;         # c is /0, 1, 4, 9 ... 2500/
dg <- /0..1..50/^2; # d is /0, 1, 4, 9 ... 2500/

# One can explicitly yield an array from generator:

g = dg[!]  # is an array of integral types values

(# Two lines below describes identical entity array
 # of 2D points. The first case uses statical array
 # of (x,y) pairs while the second utilizes
 # multivariative generator conception. As in C++, namespaces
 # are specified with :: postfix.
 #)

spatial::Point points1(..) := [{1, 4}, {2, 5}, {3, 6}];
spatial::Point points2(..) <- {[1, 2, 3], [4, 5, 6]};

Bool isEqual = points1 == points2[!];  # will be evald to true

#
# Mathematical functions:

f(x) <- [M::exp(-x)/M::pi, x/2];  # will always return a []



#
# What this will be used for (practical snippet)
#

#
# 3D modelling CAD-like

Box box1( 1., 1., 1. ),         # Created as box centered in origin
                                # with height = width = depth = 1.
    box2( {-0.5, -0.5, -1},
          { 0.5,  0.5,  1} );   # overloaded, automatically deduced ctr (point1, point2)

spatial::Boolean<subtraction> result(box1, box2);

#
# Config file
#
# This language allows to define some kind of own config file format
# since "varname = {...}" construction without explicit type programmatically
# exists in intermediate representation -- as an associative array.

root = {
    verbosity : 1;
    paths : {
        inputFile : "~/input.dat";
        outputFile : "/tmp/out.dat";
    },
    transformation(x) <- x  > 0 ? log(x^2),
                      |- x == 0 ? 0,
                      ^-          x;
};

#
# Tensors
#
# Are defined similar to function or vector function except additional
# construction `[[...]]', where co-/contravariant indexes can be denoted.
# Each index consists of two parts: variance prefix (^ or _ for contra- and
# contravariant respectively) and, optionally, the index name. Index names
# are sometimes necessary (e.g. to implemnt a conditional tensor).

a[[``,]](x) <- {
        { 1,    0,   0 },
        { 0, f(x),   0 },
        { 0,    0, 1/x }
    };

\lambda[[`i `j ,k]] = {
    { { 1, 0 },
      { 0, 1 }, },
    { { 1, 0 },
      { 0, 1 }, },
};

