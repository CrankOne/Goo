#
# Basics: literals, variables
#

a1 = 1;                 # Named numerical constant declaration of Integral class.

T::Int8 b1 = 2;         # Named numerical constant declaration of explicitly
                        # specified integral type of 8bit length.

T::Float8 c1 = 6/2;     # Arithmetics will be evaluated whenever it is possible.

\Lambda_1 = 1.23;       # You can use a backslash '\' at the beginning of literal
                        # usually to denote a special meaning of name of a variable
                        # or a function in order to keep it for polygraphic needs.
                        # Some system-special names has a backslash also.

d1, e1 = 1, 2;          # Kind of a parallel assignment is possible, but
# f, g = 0x1, "two";    # this form of mixing types is forbidden.


#
# Lists
#

a2 = { 1, 2, 3 };       # a positional array of simple type (not a list).
b2 = { 1e-3,
       2e-3,
       3e-4};
c2 = {  "one",
        "two",
        "three" };      # positional array can contain a string.
{ 0x1u, "two", 3.45,
        { a1, {} },
    };                  # lists can contain any expression except declarations.
                        # Note, that a trailing comma do not causes an error or
                        # warning.

a2[0];                  # lists can be seen as a positional uniform-indexed arrays
                        # starting from 0.


#
# Hash tables
#

a3 = {                  # Hashing lists consists of a pairs "key : value".
    one     : 1,        # For standard types (numbers and strings) the hashing
    two     : 2,        # or comparison function can be omitted. But for
    three   : 3,        # nonstandard keys, hashing or comparison function
    four    : {         # should be defined.
            1 : 0x1,    # For standard key types it is required that all keys
            2 : 0x2     # have the same type.
        },
    five    : 4,        # Trailing comma is allowed here too.
};

# Custom hashing/comparison can be provided via special attributes
# in associative array:
#
#{ \hashF : SomeCustomModule::my_pair_hashing,
#    {1, 2} : 1,
#    {3, 4} : 2
#};

#{ \compF : SomeCustomModule::my_pair_comparison,
#    {1, 2} : 1,
#    {3, 4} : 2
#};

b3 = ( a2 <- c2  );     # Hash table can be defined as a more complex object that
c3 = ( a2 -> c2  );     # implies injection or bijection of multiple sets into
d3 = ( a2 <-> c2 );     # each other. Dimensions of sets should be the same and be
                        # homogenious by type.

e3 = ( a2 <->           # You can even construct a kind of relational DB
       b2 <->           # using some bijections.
       c2 );

# Note, that you can specify a hashing or comparison function using following notations:
#   a </my_pair_hashing/- b;        # for custom hashing function
#   a <//my_comparison_function/-;  # for custom comparision function
#   a </hashing/comparision/-b;     # for both.
# 

a2["one"]; c3[2]        # Getting an injection result (form #1)
a2(one);   c3(2)        # Getting an injection result (form #2)

#
# Functions
#

f4(x, y) <- x^b1 + (y%5)*(0.13-x);


#
# A bit of functional programming
#

#
# Generators are not a usual variable

ag <- /0..1..50/;
bg <- ag*10;        # b is /0..10..500/
cg <- ag^2;         # c is /0, 1, 4, 9 ... 2500/
dg <- /0..1..50/^2; # d is /0, 1, 4, 9 ... 2500/

# One can explicitly yield an array from generator:

g = dg[!]  # is an array of integral types values

(# Two lines below describes identical entity array
 # of 2D points. The first case uses statical array
 # of (x,y) pairs while the second utilizes
 # multivariative generator conception. As in C++, namespaces
 # are specified with :: postfix.
 #)

spatial::Point points1(..) := [{1, 4}, {2, 5}, {3, 6}];
spatial::Point points2(..) <- {[1, 2, 3], [4, 5, 6]};

Bool isEqual = points1 == points2[!];  # will be evald to true

#
# Mathematical functions:

f(x) <- [M::exp(-x)/M::pi, x/2];  # will always return a []



#
# What this will be used for (practical snippet)
#

#
# 3D modelling CAD-like

Box box1( 1., 1., 1. ),         # Created as box centered in origin
                                # with height = width = depth = 1.
    box2( {-0.5, -0.5, -1},
          { 0.5,  0.5,  1} );   # overloaded, automatically deduced ctr (point1, point2)

spatial::Boolean<subtraction> result(box1, box2);

#
# Config file
#
# This language allows to define some kind of own config file format
# since "varname = {...}" construction without explicit type programmatically
# exists in intermediate representation -- as an associative array.

root = {
    verbosity : 1;
    paths : {
        inputFile : "~/input.dat";
        outputFile : "/tmp/out.dat";
    },
    transformation(x) <- x  > 0 ? log(x^2),
                      |- x == 0 ? 0,
                      ^-          x;
};

#
# Tensors
#
# Are defined similar to function or vector function except additional
# construction `[[...]]', where co-/contravariant indexes can be denoted.
# Each index consists of two parts: variance prefix (^ or _ for contra- and
# contravariant respectively) and, optionally, the index name. Index names
# are sometimes necessary (e.g. to implemnt a conditional tensor).

a[[``,]](x) <- {
        { 1,    0,   0 },
        { 0, f(x),   0 },
        { 0,    0, 1/x }
    };

\lambda[[`i `j ,k]] = {
    { { 1, 0 },
      { 0, 1 }, },
    { { 1, 0 },
      { 0, 1 }, },
};

